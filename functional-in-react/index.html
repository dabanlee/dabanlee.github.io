<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        
            React 中的函数式思想 - 大板栗想写点东西
        
    </title>
    <meta name="keywords" content>
    <meta name="description" content>
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/dist/css/github-gist.css">
    <link rel="stylesheet" href="/dist/css/app.css">
</head>


<body data-page="article">

</body></html>
<header class="Header">
    <nav class="Nav">
        <div class="container">
            <div class="Logo">
                <a href="https://justclear.github.io">
                    <img src="/images/logo.jpg" alt="大板栗想写点东西">
                </a>
            </div>
            <ul class="menu">
                
                <li><a href="/">HOME</a></li>
                
                <li><a href="/idea">IDEA</a></li>
                
                <li><a href="https://unsplash.com/@dabanli">PHOTOGRAPHY</a></li>
                
                <li><a href="/about/">ABOUT</a></li>
                
                <li><a href="https://github.com/justclear">GITHUB</a></li>
                
            </ul>
            <div class="icon-menu js-icon-menu"></div>
        </div>
    </nav>
</header>
<ul class="menu-mobile js-menu-mobile">
    
    <li><a href="/">HOME</a></li>
    
    <li><a href="/idea">IDEA</a></li>
    
    <li><a href="https://unsplash.com/@dabanli">PHOTOGRAPHY</a></li>
    
    <li><a href="/about/">ABOUT</a></li>
    
    <li><a href="https://github.com/justclear">GITHUB</a></li>
    
</ul>


<div class="page-content">
    <div class="container">
        <article class="article">
            <header class="article-header">
                <h1 class="article-title">React 中的函数式思想</h1>
                
            </header>
            <section class="article-content">
                 <blockquote>
<p>题图：<a href="https://link.zhihu.com/?target=https%3A//dribbble.com/shots/2484828-React-Illustration" target="_blank" rel="noopener">React Illustration</a></p>
</blockquote>
<h2 id="函数式编程简要概念"><a href="#函数式编程简要概念" class="headerlink" title="函数式编程简要概念"></a>函数式编程简要概念</h2><p>函数式编程中一个核心概念之一就是纯函数，如果一个函数满足一下几个条件，就可以认为这个函数是纯函数了：</p>
<ul>
<li>它是一个函数（废话）；</li>
<li>当给定相同的输入（函数的参数）的时候，总是有相同的输出（返回值）；</li>
<li>没有副作用；</li>
<li>不依赖于函数外部状态。</li>
</ul>
<p>当一个函数满足以上条件的时候，就可以认为这个函数是纯函数了。举个栗子：</p>
<pre><code class="js">// 非纯函数
let payload = 0;
function addOne(number) {
    ++payload;
    return number + payload;
}
addOne(1); // 2
addOne(1); // 3
addOne(1); // 4

// 纯函数
function addOne(number) {
    return number + 1;
}
addOne(1); // 2
addOne(1); // 2
addOne(1); // 2</code></pre>
<p>上面两个栗子中，第一个就是典型的非纯函数，当第一次执行 <code>addOne(1)</code> 其返回的值是 <code>2</code> 没有错，但是再次执行相同函数的时候，其返回的值不再是 <code>2</code> 了，而是变成了 <code>3</code> ，对比上面列出的满足纯函数的条件，就会发现：</p>
<ul>
<li><code>addOne()</code> 给定相同的输入的时候没有返回相同的输出；</li>
<li><code>addOne()</code> 会产生副作用（会改变外部状态 <code>payload</code>）；</li>
<li><code>addOne()</code> 依赖的外部状态 <code>payload</code> 。</li>
</ul>
<p>而第二个栗子就是一个纯函数，它既不依赖外部状态也不会产生副作用，且当给定相同输入的时候，总是返回相同的输出（执行任意多次 <code>addOne(1)</code> 总是返回 <code>2</code> ）。</p>
<p>以上对纯函数概念的一些简单理解。</p>
<h2 id="React-核心理念"><a href="#React-核心理念" class="headerlink" title="React 核心理念"></a>React 核心理念</h2><p>官方给出的 React 的定义是：</p>
<blockquote>
<p>A JavaScript library for building user interfaces.</p>
</blockquote>
<p>即专注于构建 <code>View</code> 层的一个库。<code>React</code> 的核心开发者之一的 Sebastian Markbåge 认为：</p>
<p><code>UI</code> 只是把数据通过映射关系变成另一种形式的数据。给定相同的输入（数据）必然会有相同的输出（<code>UI</code>），即一个简单的纯函数。<br>React 中的函数式思想的具体体现</p>
<p>虽说 <code>View</code> 层可以当成是数据的另外一种展现形式，但在实际的 <code>React</code> 开发中，除了数据的展示以外，更重要的是还有数据的交互，举个栗子：</p>
<pre><code class="js">import React, { Component } from &#39;react&#39;;
import { fetchPosts } from &#39;path/to/api&#39;;

export default class PostList extends Component {
    constructor() {
        this.state = {
            posts: [],
        };
    }
    componentDidMount() {
        fetchPosts().then(posts =&gt; {
            this.setState({
                posts: posts,
            });
        });
    }
    render() {
        return (
            &lt;ul&gt;
                { this.state.posts.map(post =&gt; &lt;li key={post.id} onClick={this.toggleActive}&gt;{ post.title }&lt;/li&gt;) }
            &lt;/ul&gt;
        );
    }
    toggleActive() {
        //
    }
}</code></pre>
<p>这个一个典型的渲染列表的栗子，在这个栗子中除了渲染 <code>PostList</code> 外，还进行了数据的获取和事件的操作，也就意味着这个 <code>PostList</code> 组件不是一个「纯函数」。严格意义上来说这个组件还不是一个可复用的组件，比如说有这样一种业务场景，除了首页有 <code>PostList</code> 组件以外，在个人页面同样有个 <code>PostList</code> 组件，<code>UI</code> 一致但是交互逻辑不一致，这种情况下就无法复用首页的 <code>PostList</code> 组件了。为了解决这个问题，我们可以再次抽离一个真正意义上可复用的 <code>View</code> 层，它有一下几个特点：</p>
<ul>
<li>给定相同的数据（由父组件通过 <code>props</code> 传递给子组件且是唯一数据来源），总是渲染相同的 <code>UI</code> 界面；</li>
<li>组件你内部不改变数据状态；</li>
<li>不处理交互逻辑。</li>
</ul>
<p>可以发现，这个上面所列出的满足纯函数的条件非常相似，这种组件才算是真正意义上的可复用的组件，好了，Talk is cheap, show me the code:</p>
<pre><code class="js">import React, { Component } from &#39;react&#39;;
import { fetchPosts } from &#39;path/to/api&#39;;

export default class PostListContainer extends Component {
    constructor() {
        this.state = {
            posts: [],
        };
    }
    componentDidMount() {
        fetchPosts().then(posts =&gt; {
            this.setState({
                posts,
            });
        });
    }
    render() {
        return (
            &lt;PostList posts={this.state.posts} toggleActive={this.toggleActive}&gt;&lt;/PostList&gt;
        );
    }
    toggleActive() {
        //
    }
}

//
export default class PostList extends Component {
    render() {
        return (&lt;ul&gt;{ this.props.posts.map(post =&gt; &lt;li key={post.id} onClick={this.props.toggleActive}&gt;{ post.title }&lt;/li&gt;) }&lt;/ul&gt;);
    }
}</code></pre>
<p>通过这样改造之后，原本数据交互和 <code>UI</code> 展示耦合则组件就被分为了两个职责明确的新组建，即 <code>PostListContainer</code> 负责数据获取或点击等交互逻辑，而 <code>PostList</code> 则真正意义上的只负责纯粹的 <code>View</code> 层渲染。这种情况下的 <code>PostListContainer</code> 被称为 <strong><code>Container Component</code>（容器组件）</strong>，<code>PostList</code> 则被称为 <strong><code>Presentational Container</code>（展示组件）</strong>。再回到刚刚所假设的业务场景下，此时可以通过创建不同的 <code>Container Component</code> 来处理不同的交互逻辑，然后把最终的数据通过 <code>props</code> 传递给子组件 <code>PostList</code>，这样的话不管是首页还是个人都可以真正复用 <code>PostList</code> 这个 <code>Presentational Component</code> 了。</p>
<p>再回过头来思考一下前面提到的 Sebastian Markbåge 所认为的理念：</p>
<p><code>UI</code> 只是把数据通过映射关系变成另一种形式的数据。给定相同的输入（数据）必然会有相同的输出（<code>UI</code>），即一个简单的纯函数。</p>
<p>我们可以把这句话高度抽象成一个函数：<code>data =&gt; View</code>，拿前面的 Presentational Component <code>PostList</code> 来说，其中 <code>this.props.posts</code> 就是 <code>data =&gt; View</code> 中的 <code>data</code>，而整个渲染结果就是 <code>View</code>，我们再单独分析一下这个组件：</p>
<pre><code class="js">import React, { Component } from &#39;react&#39;;

export default class PostList extends Component {
    render() {
        return (&lt;ul&gt;{ this.props.posts.map(post =&gt; &lt;li key={post.id} onClick={this.props.toggleActive}&gt;{ post.title }&lt;/li&gt;) }&lt;/ul&gt;);
    }
}</code></pre>
<p>其实会发现，尽管这个组件已经很简单了，<code>this.props.posts</code> 传入数据，然后渲染结果（同时还有绑定事件，但是没有事件处理的具体逻辑），没有再做其他操作了。但我们仔细思考的话，还是会发现有两个比较明显的问题，一个是写法上还是典型的面向对象的方式来写的；其次是该组件内部还有 <code>this</code> 关键字，为什么说在这里使用关键字 <code>this</code> 是不合适的呢，因为 <code>JavaScript</code> 严格来说并不是函数式编程语言，在 <code>JavaScript</code> 中 <code>this</code> 的指向又非常容易的被改变，所以依赖于 <code>this</code> 关键字的 data 是非常不稳定的。</p>
<p>好在以上两个问题再 <code>React</code> 的 <code>v0.14</code> 版本中得到了解决，在此次版本中 <code>React</code> 有一个新的特性叫 <code>Stateless Functional Components</code>。什么意思呢？我们把上面的 <code>PostList</code> 组件以 <code>Stateless Functional Components</code> 的方式来重新编写就会一目了然了：</p>
<pre><code class="js">const PostList = props =&gt; (
    &lt;ul&gt;
        { props.posts.map(post =&gt; (&lt;li key={ post.id } onClick={ props.toggleActive }&gt;{ post.title }&lt;/li&gt;)) }
    &lt;/ul&gt;
);

// 参数解构
const PostList = ({ posts, toggleActive }) =&gt; (
    &lt;ul&gt;
        { posts.map(post =&gt; (&lt;li key={ post.id } onClick={ toggleActive }&gt;{ post.title }&lt;/li&gt;)) }
    &lt;/ul&gt;
);</code></pre>
<p>我们会发现 <code>Stateless Functional Components</code> 完美的诠释了前面所提到的 <code>data =&gt; View</code> 这个理念，不仅数据输入不依赖于 <code>this</code> 关键字，且书写风格也更像函数式风格。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在平时的开发中，应该避免数据交互逻辑与数据渲染的过于耦合，严格区分 <code>Container Component</code> 和 <code>Presentational Component</code> 的职责不仅可以更容易的复用组件，而且也容易定位问题的所在。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol>
<li><a href="https://link.zhihu.com/?target=http%3A//blog.jenkster.com/2015/12/which-programming-languages-are-functional.html" target="_blank" rel="noopener">Which Programming Languages Are Functional?</a></li>
</ol>

            </section>
            <footer class="article-meta">
                
                    <div class="follow">
                        <img src="/images/follow.png" alt="前端小专栏">
                        <p class="description">更多干货请关注公众号 <span>前端小专栏</span></p>
                    </div>
                
            </footer>
        </article>
    </div>
</div>

<footer class="Footer text-center">
    <div class="container">
        <section class="copyright">
            <a href="https://justclear.github.io">大板栗</a>
            <span>&copy; 2015 - 2019</span>
        </section>
    </div>
</footer>

    <script src="/dist/js/highlight.pack.js"></script>
    <script src="/dist/js/app.js"></script>
    <!-- <script type="text/javascript" src="https://s4.cnzz.com/z_stat.php?id=1278149431&web_id=1278149431"></script> -->
</body>
</html>

